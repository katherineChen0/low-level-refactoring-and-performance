Setup
1. extracted randall-git.tgz which contained an existing Git repo
2. initialized a new GitHub repo 
3. copied local repo to Github
4. verfied files appear on GitHub

reviewed existing code:
- randall.c is monolithic program generating random bytes
- makefile builds the program and can create tarballs
- current Makefile lacks test functionality

expanded Makefile's check to include:
- output length verification
- randomness check- clear pass/fail reporting for each test case
- auto cleanup of test artifacts

verified test functionality:
- confirmed test pass w working implementation

project structure
1. randall.c - main program that orchestrates the random number generation
2. options.[ch] - Handles command-line argument parsing
3. output.[ch] - Manages output methods (stdio and block writes)
4. rand64-hw.[ch] - Hardware RDRAND implementation
5. rand64-sw.[ch] - Software implementations (mrand48 and file input)

Implementation Details
----------------------

Command Line Options:
- -i <input> : Specifies input source:
  * rdrand (default) - Hardware RNG using RDRAND
  * mrand48_r - GNU C library's mrand48
  * /path/to/file - Read from specified file
- -o <output> : Specifies output method:
  * stdio (default) - Standard I/O
  * N - Block writes of N bytes using write()
- NBYTES : Number of random bytes to generate

Key Features Implemented:
1. Input Methods:
   - Hardware RDRAND with proper CPU feature detection
   - Software mrand48_r implementation
   - File-based random data source (/dev/random by default)

2. Output Methods:
   - Standard I/O (putchar)
   - Block writes using write() system call
   - Handles partial writes correctly

3. Error Handling:
   - Comprehensive error checking for:
     * File operations
     * System calls
     * Memory allocation
     * Invalid user input
   - Clean resource deallocation

4. Testing:
   - Added test cases in Makefile:
     * Output length verification
     * Randomness verification
     * Input method testing
     * Block output testing

Performance Considerations:
- Block writes significantly improve performance for large outputs
- Hardware RDRAND is fastest when available
- mrand48_r provides good performance for software RNG
- File I/O has higher overhead but works universally

Build Instructions:
1. make - Builds the randall executable
2. make check - Runs test cases
3. make clean - Removes build artifacts

Usage Examples:
1. ./randall 1000 - Default (rdrand + stdio)
2. ./randall -i mrand48_r -o 1024 1M - Software RNG with 1KB blocks
3. ./randall -i /dev/urandom 1G - File input with large output

Known Issues:
- None currently - all test cases pass
- Potential future improvements:
  * Additional RNG algorithms
  * More output methods
  * Better performance metrics

Dependencies:
- x86-64 CPU with RDRAND support for hardware mode
- GNU C library for mrand48_r
- Standard C library functions


Performance Results
------------------
Timing tests conducted on Intel i7-10750H @ 2.60GHz

Baseline:
time dd if=/dev/urandom ibs=8192 obs=8192 count=16384 >/dev/null
real    0m0.347s
user    0m0.003s
sys     0m0.344s

randall Tests:
1. Hardware RDRAND:
time ./randall 133562368 >/dev/null
real    0m0.412s
user    0m0.408s
sys     0m0.004s

2. Piped output:
time ./randall 133562368 | cat >/dev/null
real    0m0.521s
user    0m0.452s
sys     0m0.152s

3. File output:
time ./randall 133562368 >rand.data
real    0m0.428s
user    0m0.412s
sys     0m0.016s

4. Software mrand48_r:
time ./randall -i mrand48_r 133562368 >/dev/null
real    0m0.876s
user    0m0.872s
sys     0m0.004s

5. File input (/dev/urandom):
time ./randall -i /dev/urandom 133562368 >/dev/null
real    0m0.502s
user    0m0.048s
sys     0m0.452s

6. Block output (4KB blocks):
time ./randall -o 4096 133562368 >/dev/null
real    0m0.396s
user    0m0.384s
sys     0m0.012s

Observations:
- Hardware RDRAND is fastest (0.412s)
- Block output provides ~4% improvement over stdio
- mrand48_r is ~2x slower than hardware
- File input performance depends on system's urandom implementation
- Piped output adds about 25% overhead